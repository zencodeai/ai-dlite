/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : Ontology.g
 *     -                            On : 2010-08-01 19:38:28
 *     -                for the parser : OntologyParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

#include <antlr3.h>
#include "dltools.h"
#include "context.h"

using namespace DLITE;

/* End of Header action.
 * =============================================================================
 */
/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "OntologyParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pOntologyParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pOntologyParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pOntologyParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pOntologyParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		ISTREAM							INPUT->istream
#define		INDEX()							ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   OntologyParserTokenNames[51+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "T_KW_NAME",
        (pANTLR3_UINT8) "T_VAL_STRING",
        (pANTLR3_UINT8) "T_S_SEMI",
        (pANTLR3_UINT8) "T_KW_VERSION",
        (pANTLR3_UINT8) "T_VAL_VERSION",
        (pANTLR3_UINT8) "T_KW_ATTRIBUTE",
        (pANTLR3_UINT8) "F_ID",
        (pANTLR3_UINT8) "T_KW_INCLUDE",
        (pANTLR3_UINT8) "T_KW_NSBEGIN",
        (pANTLR3_UINT8) "T_KW_NSEND",
        (pANTLR3_UINT8) "T_SY_NAME",
        (pANTLR3_UINT8) "T_OP_DEF",
        (pANTLR3_UINT8) "T_OP_OR",
        (pANTLR3_UINT8) "T_OP_AND",
        (pANTLR3_UINT8) "T_SY_TOP",
        (pANTLR3_UINT8) "T_SY_BOTTOM",
        (pANTLR3_UINT8) "T_SY_COND",
        (pANTLR3_UINT8) "T_OP_UNIV",
        (pANTLR3_UINT8) "T_S_SLS",
        (pANTLR3_UINT8) "T_OP_EXIST",
        (pANTLR3_UINT8) "T_OP_L",
        (pANTLR3_UINT8) "T_VAL_UINT",
        (pANTLR3_UINT8) "T_OP_G",
        (pANTLR3_UINT8) "T_SY_ATTRIBUTE",
        (pANTLR3_UINT8) "T_OP_GEQ",
        (pANTLR3_UINT8) "T_OP_LEQ",
        (pANTLR3_UINT8) "T_OP_EQ",
        (pANTLR3_UINT8) "T_OP_NEQ",
        (pANTLR3_UINT8) "T_OP_NOT",
        (pANTLR3_UINT8) "T_SY_VARIABLE",
        (pANTLR3_UINT8) "T_VAL_INT",
        (pANTLR3_UINT8) "T_VAL_FLOAT",
        (pANTLR3_UINT8) "T_S_LB",
        (pANTLR3_UINT8) "T_S_COM",
        (pANTLR3_UINT8) "T_S_RB",
        (pANTLR3_UINT8) "T_KW_IN",
        (pANTLR3_UINT8) "T_S_LP",
        (pANTLR3_UINT8) "T_S_RP",
        (pANTLR3_UINT8) "T_KW_DEF",
        (pANTLR3_UINT8) "F_ALPHA",
        (pANTLR3_UINT8) "F_DIGIT",
        (pANTLR3_UINT8) "F_HEXDIGIT",
        (pANTLR3_UINT8) "T_WS",
        (pANTLR3_UINT8) "T_BCOMMENT",
        (pANTLR3_UINT8) "T_LCOMMENT",
        (pANTLR3_UINT8) "T_KW_ALIAS",
        (pANTLR3_UINT8) "T_VAL_HINT",
        (pANTLR3_UINT8) "T_OP_INC",
        (pANTLR3_UINT8) "T_S_LSB",
        (pANTLR3_UINT8) "T_S_RSB",
        (pANTLR3_UINT8) "T_S_COL"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static void	eval    (pOntologyParser ctx);
static void	s_ontology    (pOntologyParser ctx);
static void	s_header    (pOntologyParser ctx);
static void	lit_name    (pOntologyParser ctx);
static void	lit_version    (pOntologyParser ctx);
static void	s_attribute    (pOntologyParser ctx);
static void	s_include    (pOntologyParser ctx);
static void	ns_begin    (pOntologyParser ctx);
static void	ns_end    (pOntologyParser ctx);
static void	s_bloc    (pOntologyParser ctx);
static void	s_definition    (pOntologyParser ctx);
static void	s_expr    (pOntologyParser ctx);
static void	op_or    (pOntologyParser ctx);
static void	op_and    (pOntologyParser ctx);
static void	op_top    (pOntologyParser ctx);
static void	op_bottom    (pOntologyParser ctx);
static void	op_cond    (pOntologyParser ctx);
static void	op_atom    (pOntologyParser ctx);
static void	op_univ    (pOntologyParser ctx);
static void	op_exist    (pOntologyParser ctx);
static void	op_maxcard    (pOntologyParser ctx);
static void	op_mincard    (pOntologyParser ctx);
static void	op_constraint    (pOntologyParser ctx);
static void	op_not    (pOntologyParser ctx);
static void	lit_value    (pOntologyParser ctx);
static void	lit_list    (pOntologyParser ctx);
static void	op_in    (pOntologyParser ctx);
static void	lit_listitem    (pOntologyParser ctx);
static void	s_concept    (pOntologyParser ctx);
static void	s_def    (pOntologyParser ctx);
static void	lit_constant    (pOntologyParser ctx);
static void	OntologyParserFree(pOntologyParser ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Ontology.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new OntologyParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pOntologyParser
OntologyParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return OntologyParserNewSSD(instream, NULL);
}

/** \brief Create a new OntologyParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pOntologyParser
OntologyParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pOntologyParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pOntologyParser) ANTLR3_CALLOC(1, sizeof(OntologyParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in OntologyParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our OntologyParser interface
     */
    ctx->eval	= eval;
    ctx->s_ontology	= s_ontology;
    ctx->s_header	= s_header;
    ctx->lit_name	= lit_name;
    ctx->lit_version	= lit_version;
    ctx->s_attribute	= s_attribute;
    ctx->s_include	= s_include;
    ctx->ns_begin	= ns_begin;
    ctx->ns_end	= ns_end;
    ctx->s_bloc	= s_bloc;
    ctx->s_definition	= s_definition;
    ctx->s_expr	= s_expr;
    ctx->op_or	= op_or;
    ctx->op_and	= op_and;
    ctx->op_top	= op_top;
    ctx->op_bottom	= op_bottom;
    ctx->op_cond	= op_cond;
    ctx->op_atom	= op_atom;
    ctx->op_univ	= op_univ;
    ctx->op_exist	= op_exist;
    ctx->op_maxcard	= op_maxcard;
    ctx->op_mincard	= op_mincard;
    ctx->op_constraint	= op_constraint;
    ctx->op_not	= op_not;
    ctx->lit_value	= lit_value;
    ctx->lit_list	= lit_list;
    ctx->op_in	= op_in;
    ctx->lit_listitem	= lit_listitem;
    ctx->s_concept	= s_concept;
    ctx->s_def	= s_def;
    ctx->lit_constant	= lit_constant;
    ctx->free			= OntologyParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

        RECOGNIZER->displayRecognitionError = tContext::errorHdlr;
        PARSER->super = (void *)ctx;

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = OntologyParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 OntologyParserFree(pOntologyParser ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return OntologyParserTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_ontology_in_eval91  */
static	ANTLR3_BITWORD FOLLOW_s_ontology_in_eval91_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_s_ontology_in_eval91	= { FOLLOW_s_ontology_in_eval91_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_header_in_s_ontology105  */
static	ANTLR3_BITWORD FOLLOW_s_header_in_s_ontology105_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000007802) };
static  ANTLR3_BITSET_LIST FOLLOW_s_header_in_s_ontology105	= { FOLLOW_s_header_in_s_ontology105_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_bloc_in_s_ontology109  */
static	ANTLR3_BITWORD FOLLOW_s_bloc_in_s_ontology109_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000007802) };
static  ANTLR3_BITSET_LIST FOLLOW_s_bloc_in_s_ontology109	= { FOLLOW_s_bloc_in_s_ontology109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lit_name_in_s_header141  */
static	ANTLR3_BITWORD FOLLOW_lit_name_in_s_header141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000282) };
static  ANTLR3_BITSET_LIST FOLLOW_lit_name_in_s_header141	= { FOLLOW_lit_name_in_s_header141_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lit_version_in_s_header143  */
static	ANTLR3_BITWORD FOLLOW_lit_version_in_s_header143_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_lit_version_in_s_header143	= { FOLLOW_lit_version_in_s_header143_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_attribute_in_s_header147  */
static	ANTLR3_BITWORD FOLLOW_s_attribute_in_s_header147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_s_attribute_in_s_header147	= { FOLLOW_s_attribute_in_s_header147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_KW_NAME_in_lit_name179  */
static	ANTLR3_BITWORD FOLLOW_T_KW_NAME_in_lit_name179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_T_KW_NAME_in_lit_name179	= { FOLLOW_T_KW_NAME_in_lit_name179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_VAL_STRING_in_lit_name183  */
static	ANTLR3_BITWORD FOLLOW_T_VAL_STRING_in_lit_name183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_T_VAL_STRING_in_lit_name183	= { FOLLOW_T_VAL_STRING_in_lit_name183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SEMI_in_lit_name185  */
static	ANTLR3_BITWORD FOLLOW_T_S_SEMI_in_lit_name185_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SEMI_in_lit_name185	= { FOLLOW_T_S_SEMI_in_lit_name185_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_KW_VERSION_in_lit_version215  */
static	ANTLR3_BITWORD FOLLOW_T_KW_VERSION_in_lit_version215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_T_KW_VERSION_in_lit_version215	= { FOLLOW_T_KW_VERSION_in_lit_version215_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_VAL_VERSION_in_lit_version219  */
static	ANTLR3_BITWORD FOLLOW_T_VAL_VERSION_in_lit_version219_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_T_VAL_VERSION_in_lit_version219	= { FOLLOW_T_VAL_VERSION_in_lit_version219_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SEMI_in_lit_version221  */
static	ANTLR3_BITWORD FOLLOW_T_S_SEMI_in_lit_version221_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SEMI_in_lit_version221	= { FOLLOW_T_S_SEMI_in_lit_version221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_KW_ATTRIBUTE_in_s_attribute251  */
static	ANTLR3_BITWORD FOLLOW_T_KW_ATTRIBUTE_in_s_attribute251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_T_KW_ATTRIBUTE_in_s_attribute251	= { FOLLOW_T_KW_ATTRIBUTE_in_s_attribute251_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_F_ID_in_s_attribute255  */
static	ANTLR3_BITWORD FOLLOW_F_ID_in_s_attribute255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_F_ID_in_s_attribute255	= { FOLLOW_F_ID_in_s_attribute255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_VAL_STRING_in_s_attribute259  */
static	ANTLR3_BITWORD FOLLOW_T_VAL_STRING_in_s_attribute259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_T_VAL_STRING_in_s_attribute259	= { FOLLOW_T_VAL_STRING_in_s_attribute259_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SEMI_in_s_attribute261  */
static	ANTLR3_BITWORD FOLLOW_T_S_SEMI_in_s_attribute261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SEMI_in_s_attribute261	= { FOLLOW_T_S_SEMI_in_s_attribute261_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_KW_INCLUDE_in_s_include291  */
static	ANTLR3_BITWORD FOLLOW_T_KW_INCLUDE_in_s_include291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_T_KW_INCLUDE_in_s_include291	= { FOLLOW_T_KW_INCLUDE_in_s_include291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_VAL_STRING_in_s_include295  */
static	ANTLR3_BITWORD FOLLOW_T_VAL_STRING_in_s_include295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_T_VAL_STRING_in_s_include295	= { FOLLOW_T_VAL_STRING_in_s_include295_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SEMI_in_s_include297  */
static	ANTLR3_BITWORD FOLLOW_T_S_SEMI_in_s_include297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SEMI_in_s_include297	= { FOLLOW_T_S_SEMI_in_s_include297_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_KW_NSBEGIN_in_ns_begin327  */
static	ANTLR3_BITWORD FOLLOW_T_KW_NSBEGIN_in_ns_begin327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_T_KW_NSBEGIN_in_ns_begin327	= { FOLLOW_T_KW_NSBEGIN_in_ns_begin327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_F_ID_in_ns_begin331  */
static	ANTLR3_BITWORD FOLLOW_F_ID_in_ns_begin331_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_F_ID_in_ns_begin331	= { FOLLOW_F_ID_in_ns_begin331_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SEMI_in_ns_begin333  */
static	ANTLR3_BITWORD FOLLOW_T_S_SEMI_in_ns_begin333_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SEMI_in_ns_begin333	= { FOLLOW_T_S_SEMI_in_ns_begin333_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_KW_NSEND_in_ns_end363  */
static	ANTLR3_BITWORD FOLLOW_T_KW_NSEND_in_ns_end363_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_T_KW_NSEND_in_ns_end363	= { FOLLOW_T_KW_NSEND_in_ns_end363_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_F_ID_in_ns_end367  */
static	ANTLR3_BITWORD FOLLOW_F_ID_in_ns_end367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_F_ID_in_ns_end367	= { FOLLOW_F_ID_in_ns_end367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SEMI_in_ns_end369  */
static	ANTLR3_BITWORD FOLLOW_T_S_SEMI_in_ns_end369_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SEMI_in_ns_end369	= { FOLLOW_T_S_SEMI_in_ns_end369_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_definition_in_s_bloc399  */
static	ANTLR3_BITWORD FOLLOW_s_definition_in_s_bloc399_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_s_definition_in_s_bloc399	= { FOLLOW_s_definition_in_s_bloc399_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_def_in_s_bloc403  */
static	ANTLR3_BITWORD FOLLOW_s_def_in_s_bloc403_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_s_def_in_s_bloc403	= { FOLLOW_s_def_in_s_bloc403_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_include_in_s_bloc407  */
static	ANTLR3_BITWORD FOLLOW_s_include_in_s_bloc407_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_s_include_in_s_bloc407	= { FOLLOW_s_include_in_s_bloc407_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ns_begin_in_s_bloc411  */
static	ANTLR3_BITWORD FOLLOW_ns_begin_in_s_bloc411_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ns_begin_in_s_bloc411	= { FOLLOW_ns_begin_in_s_bloc411_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ns_end_in_s_bloc415  */
static	ANTLR3_BITWORD FOLLOW_ns_end_in_s_bloc415_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ns_end_in_s_bloc415	= { FOLLOW_ns_end_in_s_bloc415_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_NAME_in_s_definition437  */
static	ANTLR3_BITWORD FOLLOW_T_SY_NAME_in_s_definition437_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_NAME_in_s_definition437	= { FOLLOW_T_SY_NAME_in_s_definition437_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OP_DEF_in_s_definition439  */
static	ANTLR3_BITWORD FOLLOW_T_OP_DEF_in_s_definition439_bits[]	= { ANTLR3_UINT64_LIT(0x000001010DBC4000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OP_DEF_in_s_definition439	= { FOLLOW_T_OP_DEF_in_s_definition439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_expr_in_s_definition441  */
static	ANTLR3_BITWORD FOLLOW_s_expr_in_s_definition441_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_s_expr_in_s_definition441	= { FOLLOW_s_expr_in_s_definition441_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SEMI_in_s_definition443  */
static	ANTLR3_BITWORD FOLLOW_T_S_SEMI_in_s_definition443_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SEMI_in_s_definition443	= { FOLLOW_T_S_SEMI_in_s_definition443_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_or_in_s_expr473  */
static	ANTLR3_BITWORD FOLLOW_op_or_in_s_expr473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_or_in_s_expr473	= { FOLLOW_op_or_in_s_expr473_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_and_in_op_or504  */
static	ANTLR3_BITWORD FOLLOW_op_and_in_op_or504_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_and_in_op_or504	= { FOLLOW_op_and_in_op_or504_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OP_OR_in_op_or507  */
static	ANTLR3_BITWORD FOLLOW_T_OP_OR_in_op_or507_bits[]	= { ANTLR3_UINT64_LIT(0x000001010DBC4000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OP_OR_in_op_or507	= { FOLLOW_T_OP_OR_in_op_or507_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_and_in_op_or509  */
static	ANTLR3_BITWORD FOLLOW_op_and_in_op_or509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_and_in_op_or509	= { FOLLOW_op_and_in_op_or509_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_concept_in_op_and535  */
static	ANTLR3_BITWORD FOLLOW_s_concept_in_op_and535_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_s_concept_in_op_and535	= { FOLLOW_s_concept_in_op_and535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OP_AND_in_op_and538  */
static	ANTLR3_BITWORD FOLLOW_T_OP_AND_in_op_and538_bits[]	= { ANTLR3_UINT64_LIT(0x000001010DBC4000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OP_AND_in_op_and538	= { FOLLOW_T_OP_AND_in_op_and538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_concept_in_op_and540  */
static	ANTLR3_BITWORD FOLLOW_s_concept_in_op_and540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_s_concept_in_op_and540	= { FOLLOW_s_concept_in_op_and540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_TOP_in_op_top565  */
static	ANTLR3_BITWORD FOLLOW_T_SY_TOP_in_op_top565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_TOP_in_op_top565	= { FOLLOW_T_SY_TOP_in_op_top565_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_BOTTOM_in_op_bottom595  */
static	ANTLR3_BITWORD FOLLOW_T_SY_BOTTOM_in_op_bottom595_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_BOTTOM_in_op_bottom595	= { FOLLOW_T_SY_BOTTOM_in_op_bottom595_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_COND_in_op_cond627  */
static	ANTLR3_BITWORD FOLLOW_T_SY_COND_in_op_cond627_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_COND_in_op_cond627	= { FOLLOW_T_SY_COND_in_op_cond627_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_NAME_in_op_atom659  */
static	ANTLR3_BITWORD FOLLOW_T_SY_NAME_in_op_atom659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_NAME_in_op_atom659	= { FOLLOW_T_SY_NAME_in_op_atom659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OP_UNIV_in_op_univ689  */
static	ANTLR3_BITWORD FOLLOW_T_OP_UNIV_in_op_univ689_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OP_UNIV_in_op_univ689	= { FOLLOW_T_OP_UNIV_in_op_univ689_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_NAME_in_op_univ693  */
static	ANTLR3_BITWORD FOLLOW_T_SY_NAME_in_op_univ693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_NAME_in_op_univ693	= { FOLLOW_T_SY_NAME_in_op_univ693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SLS_in_op_univ695  */
static	ANTLR3_BITWORD FOLLOW_T_S_SLS_in_op_univ695_bits[]	= { ANTLR3_UINT64_LIT(0x000001010DBC4000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SLS_in_op_univ695	= { FOLLOW_T_S_SLS_in_op_univ695_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_concept_in_op_univ697  */
static	ANTLR3_BITWORD FOLLOW_s_concept_in_op_univ697_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_s_concept_in_op_univ697	= { FOLLOW_s_concept_in_op_univ697_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OP_EXIST_in_op_exist727  */
static	ANTLR3_BITWORD FOLLOW_T_OP_EXIST_in_op_exist727_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OP_EXIST_in_op_exist727	= { FOLLOW_T_OP_EXIST_in_op_exist727_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_NAME_in_op_exist731  */
static	ANTLR3_BITWORD FOLLOW_T_SY_NAME_in_op_exist731_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_NAME_in_op_exist731	= { FOLLOW_T_SY_NAME_in_op_exist731_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SLS_in_op_exist733  */
static	ANTLR3_BITWORD FOLLOW_T_S_SLS_in_op_exist733_bits[]	= { ANTLR3_UINT64_LIT(0x000001010DBC4000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SLS_in_op_exist733	= { FOLLOW_T_S_SLS_in_op_exist733_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_concept_in_op_exist735  */
static	ANTLR3_BITWORD FOLLOW_s_concept_in_op_exist735_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_s_concept_in_op_exist735	= { FOLLOW_s_concept_in_op_exist735_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OP_L_in_op_maxcard765  */
static	ANTLR3_BITWORD FOLLOW_T_OP_L_in_op_maxcard765_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OP_L_in_op_maxcard765	= { FOLLOW_T_OP_L_in_op_maxcard765_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_VAL_UINT_in_op_maxcard769  */
static	ANTLR3_BITWORD FOLLOW_T_VAL_UINT_in_op_maxcard769_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_VAL_UINT_in_op_maxcard769	= { FOLLOW_T_VAL_UINT_in_op_maxcard769_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SLS_in_op_maxcard771  */
static	ANTLR3_BITWORD FOLLOW_T_S_SLS_in_op_maxcard771_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SLS_in_op_maxcard771	= { FOLLOW_T_S_SLS_in_op_maxcard771_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_NAME_in_op_maxcard775  */
static	ANTLR3_BITWORD FOLLOW_T_SY_NAME_in_op_maxcard775_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_NAME_in_op_maxcard775	= { FOLLOW_T_SY_NAME_in_op_maxcard775_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SLS_in_op_maxcard777  */
static	ANTLR3_BITWORD FOLLOW_T_S_SLS_in_op_maxcard777_bits[]	= { ANTLR3_UINT64_LIT(0x000001010DBC4000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SLS_in_op_maxcard777	= { FOLLOW_T_S_SLS_in_op_maxcard777_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_concept_in_op_maxcard779  */
static	ANTLR3_BITWORD FOLLOW_s_concept_in_op_maxcard779_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_s_concept_in_op_maxcard779	= { FOLLOW_s_concept_in_op_maxcard779_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OP_G_in_op_mincard809  */
static	ANTLR3_BITWORD FOLLOW_T_OP_G_in_op_mincard809_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OP_G_in_op_mincard809	= { FOLLOW_T_OP_G_in_op_mincard809_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_VAL_UINT_in_op_mincard813  */
static	ANTLR3_BITWORD FOLLOW_T_VAL_UINT_in_op_mincard813_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_VAL_UINT_in_op_mincard813	= { FOLLOW_T_VAL_UINT_in_op_mincard813_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SLS_in_op_mincard815  */
static	ANTLR3_BITWORD FOLLOW_T_S_SLS_in_op_mincard815_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SLS_in_op_mincard815	= { FOLLOW_T_S_SLS_in_op_mincard815_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_NAME_in_op_mincard819  */
static	ANTLR3_BITWORD FOLLOW_T_SY_NAME_in_op_mincard819_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_NAME_in_op_mincard819	= { FOLLOW_T_SY_NAME_in_op_mincard819_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SLS_in_op_mincard821  */
static	ANTLR3_BITWORD FOLLOW_T_S_SLS_in_op_mincard821_bits[]	= { ANTLR3_UINT64_LIT(0x000001010DBC4000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SLS_in_op_mincard821	= { FOLLOW_T_S_SLS_in_op_mincard821_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_concept_in_op_mincard823  */
static	ANTLR3_BITWORD FOLLOW_s_concept_in_op_mincard823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_s_concept_in_op_mincard823	= { FOLLOW_s_concept_in_op_mincard823_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_ATTRIBUTE_in_op_constraint855  */
static	ANTLR3_BITWORD FOLLOW_T_SY_ATTRIBUTE_in_op_constraint855_bits[]	= { ANTLR3_UINT64_LIT(0x00000000F5000000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_ATTRIBUTE_in_op_constraint855	= { FOLLOW_T_SY_ATTRIBUTE_in_op_constraint855_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_op_constraint859  */
static	ANTLR3_BITWORD FOLLOW_set_in_op_constraint859_bits[]	= { ANTLR3_UINT64_LIT(0x0000000E02004020) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_op_constraint859	= { FOLLOW_set_in_op_constraint859_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lit_value_in_op_constraint874  */
static	ANTLR3_BITWORD FOLLOW_lit_value_in_op_constraint874_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lit_value_in_op_constraint874	= { FOLLOW_lit_value_in_op_constraint874_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lit_constant_in_op_constraint878  */
static	ANTLR3_BITWORD FOLLOW_lit_constant_in_op_constraint878_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lit_constant_in_op_constraint878	= { FOLLOW_lit_constant_in_op_constraint878_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_OP_NOT_in_op_not909  */
static	ANTLR3_BITWORD FOLLOW_T_OP_NOT_in_op_not909_bits[]	= { ANTLR3_UINT64_LIT(0x000001010DBC4000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_OP_NOT_in_op_not909	= { FOLLOW_T_OP_NOT_in_op_not909_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_concept_in_op_not911  */
static	ANTLR3_BITWORD FOLLOW_s_concept_in_op_not911_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_s_concept_in_op_not911	= { FOLLOW_s_concept_in_op_not911_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_VARIABLE_in_lit_value942  */
static	ANTLR3_BITWORD FOLLOW_T_SY_VARIABLE_in_lit_value942_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_VARIABLE_in_lit_value942	= { FOLLOW_T_SY_VARIABLE_in_lit_value942_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_VAL_UINT_in_lit_value956  */
static	ANTLR3_BITWORD FOLLOW_T_VAL_UINT_in_lit_value956_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_VAL_UINT_in_lit_value956	= { FOLLOW_T_VAL_UINT_in_lit_value956_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_VAL_INT_in_lit_value973  */
static	ANTLR3_BITWORD FOLLOW_T_VAL_INT_in_lit_value973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_VAL_INT_in_lit_value973	= { FOLLOW_T_VAL_INT_in_lit_value973_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_VAL_FLOAT_in_lit_value991  */
static	ANTLR3_BITWORD FOLLOW_T_VAL_FLOAT_in_lit_value991_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_VAL_FLOAT_in_lit_value991	= { FOLLOW_T_VAL_FLOAT_in_lit_value991_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_VAL_STRING_in_lit_value1007  */
static	ANTLR3_BITWORD FOLLOW_T_VAL_STRING_in_lit_value1007_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_VAL_STRING_in_lit_value1007	= { FOLLOW_T_VAL_STRING_in_lit_value1007_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_LB_in_lit_list1042  */
static	ANTLR3_BITWORD FOLLOW_T_S_LB_in_lit_list1042_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_LB_in_lit_list1042	= { FOLLOW_T_S_LB_in_lit_list1042_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lit_listitem_in_lit_list1044  */
static	ANTLR3_BITWORD FOLLOW_lit_listitem_in_lit_list1044_bits[]	= { ANTLR3_UINT64_LIT(0x0000006000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_lit_listitem_in_lit_list1044	= { FOLLOW_lit_listitem_in_lit_list1044_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_COM_in_lit_list1047  */
static	ANTLR3_BITWORD FOLLOW_T_S_COM_in_lit_list1047_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_COM_in_lit_list1047	= { FOLLOW_T_S_COM_in_lit_list1047_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lit_listitem_in_lit_list1049  */
static	ANTLR3_BITWORD FOLLOW_lit_listitem_in_lit_list1049_bits[]	= { ANTLR3_UINT64_LIT(0x0000006000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_lit_listitem_in_lit_list1049	= { FOLLOW_lit_listitem_in_lit_list1049_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_RB_in_lit_list1053  */
static	ANTLR3_BITWORD FOLLOW_T_S_RB_in_lit_list1053_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_RB_in_lit_list1053	= { FOLLOW_T_S_RB_in_lit_list1053_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_ATTRIBUTE_in_op_in1084  */
static	ANTLR3_BITWORD FOLLOW_T_SY_ATTRIBUTE_in_op_in1084_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_ATTRIBUTE_in_op_in1084	= { FOLLOW_T_SY_ATTRIBUTE_in_op_in1084_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_KW_IN_in_op_in1086  */
static	ANTLR3_BITWORD FOLLOW_T_KW_IN_in_op_in1086_bits[]	= { ANTLR3_UINT64_LIT(0x0000001E02004020) };
static  ANTLR3_BITSET_LIST FOLLOW_T_KW_IN_in_op_in1086	= { FOLLOW_T_KW_IN_in_op_in1086_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lit_list_in_op_in1089  */
static	ANTLR3_BITWORD FOLLOW_lit_list_in_op_in1089_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lit_list_in_op_in1089	= { FOLLOW_lit_list_in_op_in1089_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lit_constant_in_op_in1093  */
static	ANTLR3_BITWORD FOLLOW_lit_constant_in_op_in1093_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lit_constant_in_op_in1093	= { FOLLOW_lit_constant_in_op_in1093_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_NAME_in_lit_listitem1125  */
static	ANTLR3_BITWORD FOLLOW_T_SY_NAME_in_lit_listitem1125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_NAME_in_lit_listitem1125	= { FOLLOW_T_SY_NAME_in_lit_listitem1125_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_top_in_s_concept1155  */
static	ANTLR3_BITWORD FOLLOW_op_top_in_s_concept1155_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_top_in_s_concept1155	= { FOLLOW_op_top_in_s_concept1155_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_bottom_in_s_concept1159  */
static	ANTLR3_BITWORD FOLLOW_op_bottom_in_s_concept1159_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_bottom_in_s_concept1159	= { FOLLOW_op_bottom_in_s_concept1159_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_cond_in_s_concept1163  */
static	ANTLR3_BITWORD FOLLOW_op_cond_in_s_concept1163_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_cond_in_s_concept1163	= { FOLLOW_op_cond_in_s_concept1163_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_univ_in_s_concept1167  */
static	ANTLR3_BITWORD FOLLOW_op_univ_in_s_concept1167_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_univ_in_s_concept1167	= { FOLLOW_op_univ_in_s_concept1167_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_exist_in_s_concept1171  */
static	ANTLR3_BITWORD FOLLOW_op_exist_in_s_concept1171_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_exist_in_s_concept1171	= { FOLLOW_op_exist_in_s_concept1171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_maxcard_in_s_concept1175  */
static	ANTLR3_BITWORD FOLLOW_op_maxcard_in_s_concept1175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_maxcard_in_s_concept1175	= { FOLLOW_op_maxcard_in_s_concept1175_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_mincard_in_s_concept1179  */
static	ANTLR3_BITWORD FOLLOW_op_mincard_in_s_concept1179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_mincard_in_s_concept1179	= { FOLLOW_op_mincard_in_s_concept1179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_constraint_in_s_concept1183  */
static	ANTLR3_BITWORD FOLLOW_op_constraint_in_s_concept1183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_constraint_in_s_concept1183	= { FOLLOW_op_constraint_in_s_concept1183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_in_in_s_concept1187  */
static	ANTLR3_BITWORD FOLLOW_op_in_in_s_concept1187_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_in_in_s_concept1187	= { FOLLOW_op_in_in_s_concept1187_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_atom_in_s_concept1191  */
static	ANTLR3_BITWORD FOLLOW_op_atom_in_s_concept1191_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_atom_in_s_concept1191	= { FOLLOW_op_atom_in_s_concept1191_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_op_not_in_s_concept1195  */
static	ANTLR3_BITWORD FOLLOW_op_not_in_s_concept1195_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_op_not_in_s_concept1195	= { FOLLOW_op_not_in_s_concept1195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_LP_in_s_concept1205  */
static	ANTLR3_BITWORD FOLLOW_T_S_LP_in_s_concept1205_bits[]	= { ANTLR3_UINT64_LIT(0x000001010DBC4000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_LP_in_s_concept1205	= { FOLLOW_T_S_LP_in_s_concept1205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_s_expr_in_s_concept1207  */
static	ANTLR3_BITWORD FOLLOW_s_expr_in_s_concept1207_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_s_expr_in_s_concept1207	= { FOLLOW_s_expr_in_s_concept1207_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_RP_in_s_concept1209  */
static	ANTLR3_BITWORD FOLLOW_T_S_RP_in_s_concept1209_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_RP_in_s_concept1209	= { FOLLOW_T_S_RP_in_s_concept1209_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_KW_DEF_in_s_def1239  */
static	ANTLR3_BITWORD FOLLOW_T_KW_DEF_in_s_def1239_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_T_KW_DEF_in_s_def1239	= { FOLLOW_T_KW_DEF_in_s_def1239_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_NAME_in_s_def1243  */
static	ANTLR3_BITWORD FOLLOW_T_SY_NAME_in_s_def1243_bits[]	= { ANTLR3_UINT64_LIT(0x0000001E02000020) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_NAME_in_s_def1243	= { FOLLOW_T_SY_NAME_in_s_def1243_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lit_value_in_s_def1246  */
static	ANTLR3_BITWORD FOLLOW_lit_value_in_s_def1246_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_lit_value_in_s_def1246	= { FOLLOW_lit_value_in_s_def1246_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lit_list_in_s_def1250  */
static	ANTLR3_BITWORD FOLLOW_lit_list_in_s_def1250_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_lit_list_in_s_def1250	= { FOLLOW_lit_list_in_s_def1250_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_S_SEMI_in_s_def1253  */
static	ANTLR3_BITWORD FOLLOW_T_S_SEMI_in_s_def1253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_S_SEMI_in_s_def1253	= { FOLLOW_T_S_SEMI_in_s_def1253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_T_SY_NAME_in_lit_constant1285  */
static	ANTLR3_BITWORD FOLLOW_T_SY_NAME_in_lit_constant1285_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_T_SY_NAME_in_lit_constant1285	= { FOLLOW_T_SY_NAME_in_lit_constant1285_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start eval
 * Ontology.g:59:1: eval : s_ontology ;
 */
static void
eval(pOntologyParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // Ontology.g:59:6: ( s_ontology )
        // Ontology.g:59:8: s_ontology
        {
            FOLLOWPUSH(FOLLOW_s_ontology_in_eval91);
            s_ontology(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleevalEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleevalEx; /* Prevent compiler warnings */
    ruleevalEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end eval */

/** 
 * $ANTLR start s_ontology
 * Ontology.g:61:1: s_ontology : ( s_header )? ( s_bloc )* ;
 */
static void
s_ontology(pOntologyParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // Ontology.g:62:5: ( ( s_header )? ( s_bloc )* )
        // Ontology.g:62:9: ( s_header )? ( s_bloc )*
        {

            // Ontology.g:62:9: ( s_header )?
            {
                int alt1=2;
                switch ( LA(1) ) 
                {
                    case T_KW_NAME:
                    	{
                    		alt1=1;
                    	}
                        break;
                }

                switch (alt1) 
                {
            	case 1:
            	    // Ontology.g:62:9: s_header
            	    {
            	        FOLLOWPUSH(FOLLOW_s_header_in_s_ontology105);
            	        s_header(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rules_ontologyEx;
            	        }


            	    }
            	    break;

                }
            }

            // Ontology.g:62:19: ( s_bloc )*

            for (;;)
            {
                int alt2=2;
                switch ( LA(1) ) 
                {
                case T_KW_INCLUDE:
                case T_KW_NSBEGIN:
                case T_KW_NSEND:
                case T_SY_NAME:
                case T_KW_DEF:
                	{
                		alt2=1;
                	}
                    break;

                }

                switch (alt2) 
                {
            	case 1:
            	    // Ontology.g:62:20: s_bloc
            	    {
            	        FOLLOWPUSH(FOLLOW_s_bloc_in_s_ontology109);
            	        s_bloc(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rules_ontologyEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop2;	/* break out of the loop */
            	    break;
                }
            }
            loop2: ; /* Jump out to here if this rule does not match */

            {
                 ctx->m_spContext->s_ontology(); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rules_ontologyEx; /* Prevent compiler warnings */
    rules_ontologyEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end s_ontology */

/** 
 * $ANTLR start s_header
 * Ontology.g:67:1: s_header : lit_name ( lit_version )? ( s_attribute )* ;
 */
static void
s_header(pOntologyParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // Ontology.g:68:5: ( lit_name ( lit_version )? ( s_attribute )* )
        // Ontology.g:68:9: lit_name ( lit_version )? ( s_attribute )*
        {
            FOLLOWPUSH(FOLLOW_lit_name_in_s_header141);
            lit_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rules_headerEx;
            }


            // Ontology.g:68:18: ( lit_version )?
            {
                int alt3=2;
                switch ( LA(1) ) 
                {
                    case T_KW_VERSION:
                    	{
                    		alt3=1;
                    	}
                        break;
                }

                switch (alt3) 
                {
            	case 1:
            	    // Ontology.g:68:18: lit_version
            	    {
            	        FOLLOWPUSH(FOLLOW_lit_version_in_s_header143);
            	        lit_version(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rules_headerEx;
            	        }


            	    }
            	    break;

                }
            }

            // Ontology.g:68:31: ( s_attribute )*

            for (;;)
            {
                int alt4=2;
                switch ( LA(1) ) 
                {
                case T_KW_ATTRIBUTE:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4) 
                {
            	case 1:
            	    // Ontology.g:68:32: s_attribute
            	    {
            	        FOLLOWPUSH(FOLLOW_s_attribute_in_s_header147);
            	        s_attribute(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rules_headerEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */

            {
                 ctx->m_spContext->s_header(); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rules_headerEx; /* Prevent compiler warnings */
    rules_headerEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end s_header */

/** 
 * $ANTLR start lit_name
 * Ontology.g:73:1: lit_name : T_KW_NAME v= T_VAL_STRING T_S_SEMI ;
 */
static void
lit_name(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    v;

    /* Initialize rule variables
     */


    v       = NULL;

    {
        // Ontology.g:74:5: ( T_KW_NAME v= T_VAL_STRING T_S_SEMI )
        // Ontology.g:74:9: T_KW_NAME v= T_VAL_STRING T_S_SEMI
        {
             MATCHT(T_KW_NAME, &FOLLOW_T_KW_NAME_in_lit_name179); 
            if  (HASEXCEPTION())
            {
                goto rulelit_nameEx;
            }

            v = (pANTLR3_COMMON_TOKEN) MATCHT(T_VAL_STRING, &FOLLOW_T_VAL_STRING_in_lit_name183); 
            if  (HASEXCEPTION())
            {
                goto rulelit_nameEx;
            }

             MATCHT(T_S_SEMI, &FOLLOW_T_S_SEMI_in_lit_name185); 
            if  (HASEXCEPTION())
            {
                goto rulelit_nameEx;
            }

            {
                 ctx->m_spContext->lit_name(v); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelit_nameEx; /* Prevent compiler warnings */
    rulelit_nameEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end lit_name */

/** 
 * $ANTLR start lit_version
 * Ontology.g:79:1: lit_version : T_KW_VERSION v= T_VAL_VERSION T_S_SEMI ;
 */
static void
lit_version(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    v;

    /* Initialize rule variables
     */


    v       = NULL;

    {
        // Ontology.g:80:5: ( T_KW_VERSION v= T_VAL_VERSION T_S_SEMI )
        // Ontology.g:80:9: T_KW_VERSION v= T_VAL_VERSION T_S_SEMI
        {
             MATCHT(T_KW_VERSION, &FOLLOW_T_KW_VERSION_in_lit_version215); 
            if  (HASEXCEPTION())
            {
                goto rulelit_versionEx;
            }

            v = (pANTLR3_COMMON_TOKEN) MATCHT(T_VAL_VERSION, &FOLLOW_T_VAL_VERSION_in_lit_version219); 
            if  (HASEXCEPTION())
            {
                goto rulelit_versionEx;
            }

             MATCHT(T_S_SEMI, &FOLLOW_T_S_SEMI_in_lit_version221); 
            if  (HASEXCEPTION())
            {
                goto rulelit_versionEx;
            }

            {
                 ctx->m_spContext->lit_version(v); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelit_versionEx; /* Prevent compiler warnings */
    rulelit_versionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end lit_version */

/** 
 * $ANTLR start s_attribute
 * Ontology.g:85:1: s_attribute : T_KW_ATTRIBUTE n= F_ID v= T_VAL_STRING T_S_SEMI ;
 */
static void
s_attribute(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    n;
    pANTLR3_COMMON_TOKEN    v;

    /* Initialize rule variables
     */


    n       = NULL;
    v       = NULL;

    {
        // Ontology.g:86:5: ( T_KW_ATTRIBUTE n= F_ID v= T_VAL_STRING T_S_SEMI )
        // Ontology.g:86:9: T_KW_ATTRIBUTE n= F_ID v= T_VAL_STRING T_S_SEMI
        {
             MATCHT(T_KW_ATTRIBUTE, &FOLLOW_T_KW_ATTRIBUTE_in_s_attribute251); 
            if  (HASEXCEPTION())
            {
                goto rules_attributeEx;
            }

            n = (pANTLR3_COMMON_TOKEN) MATCHT(F_ID, &FOLLOW_F_ID_in_s_attribute255); 
            if  (HASEXCEPTION())
            {
                goto rules_attributeEx;
            }

            v = (pANTLR3_COMMON_TOKEN) MATCHT(T_VAL_STRING, &FOLLOW_T_VAL_STRING_in_s_attribute259); 
            if  (HASEXCEPTION())
            {
                goto rules_attributeEx;
            }

             MATCHT(T_S_SEMI, &FOLLOW_T_S_SEMI_in_s_attribute261); 
            if  (HASEXCEPTION())
            {
                goto rules_attributeEx;
            }

            {
                 ctx->m_spContext->s_attribute(n, v); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rules_attributeEx; /* Prevent compiler warnings */
    rules_attributeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end s_attribute */

/** 
 * $ANTLR start s_include
 * Ontology.g:91:1: s_include : T_KW_INCLUDE v= T_VAL_STRING T_S_SEMI ;
 */
static void
s_include(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    v;

    /* Initialize rule variables
     */


    v       = NULL;

    {
        // Ontology.g:92:5: ( T_KW_INCLUDE v= T_VAL_STRING T_S_SEMI )
        // Ontology.g:92:9: T_KW_INCLUDE v= T_VAL_STRING T_S_SEMI
        {
             MATCHT(T_KW_INCLUDE, &FOLLOW_T_KW_INCLUDE_in_s_include291); 
            if  (HASEXCEPTION())
            {
                goto rules_includeEx;
            }

            v = (pANTLR3_COMMON_TOKEN) MATCHT(T_VAL_STRING, &FOLLOW_T_VAL_STRING_in_s_include295); 
            if  (HASEXCEPTION())
            {
                goto rules_includeEx;
            }

             MATCHT(T_S_SEMI, &FOLLOW_T_S_SEMI_in_s_include297); 
            if  (HASEXCEPTION())
            {
                goto rules_includeEx;
            }

            {
                 ctx->m_spContext->s_include(v); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rules_includeEx; /* Prevent compiler warnings */
    rules_includeEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end s_include */

/** 
 * $ANTLR start ns_begin
 * Ontology.g:97:1: ns_begin : T_KW_NSBEGIN v= F_ID T_S_SEMI ;
 */
static void
ns_begin(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    v;

    /* Initialize rule variables
     */


    v       = NULL;

    {
        // Ontology.g:98:5: ( T_KW_NSBEGIN v= F_ID T_S_SEMI )
        // Ontology.g:98:9: T_KW_NSBEGIN v= F_ID T_S_SEMI
        {
             MATCHT(T_KW_NSBEGIN, &FOLLOW_T_KW_NSBEGIN_in_ns_begin327); 
            if  (HASEXCEPTION())
            {
                goto rulens_beginEx;
            }

            v = (pANTLR3_COMMON_TOKEN) MATCHT(F_ID, &FOLLOW_F_ID_in_ns_begin331); 
            if  (HASEXCEPTION())
            {
                goto rulens_beginEx;
            }

             MATCHT(T_S_SEMI, &FOLLOW_T_S_SEMI_in_ns_begin333); 
            if  (HASEXCEPTION())
            {
                goto rulens_beginEx;
            }

            {
                 ctx->m_spContext->ns_begin(v); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulens_beginEx; /* Prevent compiler warnings */
    rulens_beginEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end ns_begin */

/** 
 * $ANTLR start ns_end
 * Ontology.g:103:1: ns_end : T_KW_NSEND v= F_ID T_S_SEMI ;
 */
static void
ns_end(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    v;

    /* Initialize rule variables
     */


    v       = NULL;

    {
        // Ontology.g:104:5: ( T_KW_NSEND v= F_ID T_S_SEMI )
        // Ontology.g:104:9: T_KW_NSEND v= F_ID T_S_SEMI
        {
             MATCHT(T_KW_NSEND, &FOLLOW_T_KW_NSEND_in_ns_end363); 
            if  (HASEXCEPTION())
            {
                goto rulens_endEx;
            }

            v = (pANTLR3_COMMON_TOKEN) MATCHT(F_ID, &FOLLOW_F_ID_in_ns_end367); 
            if  (HASEXCEPTION())
            {
                goto rulens_endEx;
            }

             MATCHT(T_S_SEMI, &FOLLOW_T_S_SEMI_in_ns_end369); 
            if  (HASEXCEPTION())
            {
                goto rulens_endEx;
            }

            {
                 ctx->m_spContext->ns_end(); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulens_endEx; /* Prevent compiler warnings */
    rulens_endEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end ns_end */

/** 
 * $ANTLR start s_bloc
 * Ontology.g:109:1: s_bloc : ( s_definition | s_def | s_include | ns_begin | ns_end );
 */
static void
s_bloc(pOntologyParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  Ontology.g:110:5: ( s_definition | s_def | s_include | ns_begin | ns_end )
            
            ANTLR3_UINT32 alt5;

            alt5=5;

            switch ( LA(1) ) 
            {
            case T_SY_NAME:
            	{
            		alt5=1;
            	}
                break;
            case T_KW_DEF:
            	{
            		alt5=2;
            	}
                break;
            case T_KW_INCLUDE:
            	{
            		alt5=3;
            	}
                break;
            case T_KW_NSBEGIN:
            	{
            		alt5=4;
            	}
                break;
            case T_KW_NSEND:
            	{
            		alt5=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto rules_blocEx;
            }

            switch (alt5) 
            {
        	case 1:
        	    // Ontology.g:110:9: s_definition
        	    {
        	        FOLLOWPUSH(FOLLOW_s_definition_in_s_bloc399);
        	        s_definition(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_blocEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Ontology.g:110:24: s_def
        	    {
        	        FOLLOWPUSH(FOLLOW_s_def_in_s_bloc403);
        	        s_def(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_blocEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Ontology.g:110:32: s_include
        	    {
        	        FOLLOWPUSH(FOLLOW_s_include_in_s_bloc407);
        	        s_include(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_blocEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // Ontology.g:110:44: ns_begin
        	    {
        	        FOLLOWPUSH(FOLLOW_ns_begin_in_s_bloc411);
        	        ns_begin(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_blocEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // Ontology.g:110:55: ns_end
        	    {
        	        FOLLOWPUSH(FOLLOW_ns_end_in_s_bloc415);
        	        ns_end(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_blocEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rules_blocEx; /* Prevent compiler warnings */
    rules_blocEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end s_bloc */

/** 
 * $ANTLR start s_definition
 * Ontology.g:114:1: s_definition : n= T_SY_NAME T_OP_DEF s_expr T_S_SEMI ;
 */
static void
s_definition(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    n;

    /* Initialize rule variables
     */


    n       = NULL;

    {
        // Ontology.g:115:5: (n= T_SY_NAME T_OP_DEF s_expr T_S_SEMI )
        // Ontology.g:115:9: n= T_SY_NAME T_OP_DEF s_expr T_S_SEMI
        {
            n = (pANTLR3_COMMON_TOKEN) MATCHT(T_SY_NAME, &FOLLOW_T_SY_NAME_in_s_definition437); 
            if  (HASEXCEPTION())
            {
                goto rules_definitionEx;
            }

             MATCHT(T_OP_DEF, &FOLLOW_T_OP_DEF_in_s_definition439); 
            if  (HASEXCEPTION())
            {
                goto rules_definitionEx;
            }

            FOLLOWPUSH(FOLLOW_s_expr_in_s_definition441);
            s_expr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rules_definitionEx;
            }

             MATCHT(T_S_SEMI, &FOLLOW_T_S_SEMI_in_s_definition443); 
            if  (HASEXCEPTION())
            {
                goto rules_definitionEx;
            }

            {
                 ctx->m_spContext->s_definition(n); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rules_definitionEx; /* Prevent compiler warnings */
    rules_definitionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end s_definition */

/** 
 * $ANTLR start s_expr
 * Ontology.g:120:1: s_expr : op_or ;
 */
static void
s_expr(pOntologyParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // Ontology.g:121:5: ( op_or )
        // Ontology.g:121:9: op_or
        {
            FOLLOWPUSH(FOLLOW_op_or_in_s_expr473);
            op_or(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rules_exprEx;
            }

            {
                 ctx->m_spContext->s_expr(); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rules_exprEx; /* Prevent compiler warnings */
    rules_exprEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end s_expr */

/** 
 * $ANTLR start op_or
 * Ontology.g:126:1: op_or : ( op_and ( T_OP_OR op_and )* ) ;
 */
static void
op_or(pOntologyParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // Ontology.g:127:5: ( ( op_and ( T_OP_OR op_and )* ) )
        // Ontology.g:127:9: ( op_and ( T_OP_OR op_and )* )
        {
            // Ontology.g:127:9: ( op_and ( T_OP_OR op_and )* )
            // Ontology.g:127:10: op_and ( T_OP_OR op_and )*
            {
                FOLLOWPUSH(FOLLOW_op_and_in_op_or504);
                op_and(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleop_orEx;
                }


                // Ontology.g:127:17: ( T_OP_OR op_and )*

                for (;;)
                {
                    int alt6=2;
                    switch ( LA(1) ) 
                    {
                    case T_OP_OR:
                    	{
                    		alt6=1;
                    	}
                        break;

                    }

                    switch (alt6) 
                    {
                	case 1:
                	    // Ontology.g:127:18: T_OP_OR op_and
                	    {
                	         MATCHT(T_OP_OR, &FOLLOW_T_OP_OR_in_op_or507); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleop_orEx;
                	        }

                	        FOLLOWPUSH(FOLLOW_op_and_in_op_or509);
                	        op_and(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleop_orEx;
                	        }

                	        {
                	             ctx->m_spContext->op_or(); 
                	        }

                	    }
                	    break;

                	default:
                	    goto loop6;	/* break out of the loop */
                	    break;
                    }
                }
                loop6: ; /* Jump out to here if this rule does not match */


            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleop_orEx; /* Prevent compiler warnings */
    ruleop_orEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end op_or */

/** 
 * $ANTLR start op_and
 * Ontology.g:131:1: op_and : ( s_concept ( T_OP_AND s_concept )* ) ;
 */
static void
op_and(pOntologyParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // Ontology.g:132:5: ( ( s_concept ( T_OP_AND s_concept )* ) )
        // Ontology.g:132:9: ( s_concept ( T_OP_AND s_concept )* )
        {
            // Ontology.g:132:9: ( s_concept ( T_OP_AND s_concept )* )
            // Ontology.g:132:10: s_concept ( T_OP_AND s_concept )*
            {
                FOLLOWPUSH(FOLLOW_s_concept_in_op_and535);
                s_concept(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleop_andEx;
                }


                // Ontology.g:132:20: ( T_OP_AND s_concept )*

                for (;;)
                {
                    int alt7=2;
                    switch ( LA(1) ) 
                    {
                    case T_OP_AND:
                    	{
                    		alt7=1;
                    	}
                        break;

                    }

                    switch (alt7) 
                    {
                	case 1:
                	    // Ontology.g:132:21: T_OP_AND s_concept
                	    {
                	         MATCHT(T_OP_AND, &FOLLOW_T_OP_AND_in_op_and538); 
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleop_andEx;
                	        }

                	        FOLLOWPUSH(FOLLOW_s_concept_in_op_and540);
                	        s_concept(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleop_andEx;
                	        }

                	        {
                	             ctx->m_spContext->op_and(); 
                	        }

                	    }
                	    break;

                	default:
                	    goto loop7;	/* break out of the loop */
                	    break;
                    }
                }
                loop7: ; /* Jump out to here if this rule does not match */


            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleop_andEx; /* Prevent compiler warnings */
    ruleop_andEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end op_and */

/** 
 * $ANTLR start op_top
 * Ontology.g:136:1: op_top : T_SY_TOP ;
 */
static void
op_top(pOntologyParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // Ontology.g:137:5: ( T_SY_TOP )
        // Ontology.g:137:9: T_SY_TOP
        {
             MATCHT(T_SY_TOP, &FOLLOW_T_SY_TOP_in_op_top565); 
            if  (HASEXCEPTION())
            {
                goto ruleop_topEx;
            }

            {
                 ctx->m_spContext->op_top(); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleop_topEx; /* Prevent compiler warnings */
    ruleop_topEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end op_top */

/** 
 * $ANTLR start op_bottom
 * Ontology.g:142:1: op_bottom : T_SY_BOTTOM ;
 */
static void
op_bottom(pOntologyParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // Ontology.g:143:5: ( T_SY_BOTTOM )
        // Ontology.g:143:9: T_SY_BOTTOM
        {
             MATCHT(T_SY_BOTTOM, &FOLLOW_T_SY_BOTTOM_in_op_bottom595); 
            if  (HASEXCEPTION())
            {
                goto ruleop_bottomEx;
            }

            {
                 ctx->m_spContext->op_bottom(); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleop_bottomEx; /* Prevent compiler warnings */
    ruleop_bottomEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end op_bottom */

/** 
 * $ANTLR start op_cond
 * Ontology.g:148:1: op_cond : v= T_SY_COND ;
 */
static void
op_cond(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    v;

    /* Initialize rule variables
     */


    v       = NULL;

    {
        // Ontology.g:149:5: (v= T_SY_COND )
        // Ontology.g:149:9: v= T_SY_COND
        {
            v = (pANTLR3_COMMON_TOKEN) MATCHT(T_SY_COND, &FOLLOW_T_SY_COND_in_op_cond627); 
            if  (HASEXCEPTION())
            {
                goto ruleop_condEx;
            }

            {
                 ctx->m_spContext->op_cond(v); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleop_condEx; /* Prevent compiler warnings */
    ruleop_condEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end op_cond */

/** 
 * $ANTLR start op_atom
 * Ontology.g:154:1: op_atom : v= T_SY_NAME ;
 */
static void
op_atom(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    v;

    /* Initialize rule variables
     */


    v       = NULL;

    {
        // Ontology.g:155:5: (v= T_SY_NAME )
        // Ontology.g:155:9: v= T_SY_NAME
        {
            v = (pANTLR3_COMMON_TOKEN) MATCHT(T_SY_NAME, &FOLLOW_T_SY_NAME_in_op_atom659); 
            if  (HASEXCEPTION())
            {
                goto ruleop_atomEx;
            }

            {
                 ctx->m_spContext->op_atom(v); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleop_atomEx; /* Prevent compiler warnings */
    ruleop_atomEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end op_atom */

/** 
 * $ANTLR start op_univ
 * Ontology.g:160:1: op_univ : T_OP_UNIV r= T_SY_NAME T_S_SLS s_concept ;
 */
static void
op_univ(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    r;

    /* Initialize rule variables
     */


    r       = NULL;

    {
        // Ontology.g:161:5: ( T_OP_UNIV r= T_SY_NAME T_S_SLS s_concept )
        // Ontology.g:161:9: T_OP_UNIV r= T_SY_NAME T_S_SLS s_concept
        {
             MATCHT(T_OP_UNIV, &FOLLOW_T_OP_UNIV_in_op_univ689); 
            if  (HASEXCEPTION())
            {
                goto ruleop_univEx;
            }

            r = (pANTLR3_COMMON_TOKEN) MATCHT(T_SY_NAME, &FOLLOW_T_SY_NAME_in_op_univ693); 
            if  (HASEXCEPTION())
            {
                goto ruleop_univEx;
            }

             MATCHT(T_S_SLS, &FOLLOW_T_S_SLS_in_op_univ695); 
            if  (HASEXCEPTION())
            {
                goto ruleop_univEx;
            }

            FOLLOWPUSH(FOLLOW_s_concept_in_op_univ697);
            s_concept(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleop_univEx;
            }

            {
                 ctx->m_spContext->op_univ(r); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleop_univEx; /* Prevent compiler warnings */
    ruleop_univEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end op_univ */

/** 
 * $ANTLR start op_exist
 * Ontology.g:166:1: op_exist : T_OP_EXIST r= T_SY_NAME T_S_SLS s_concept ;
 */
static void
op_exist(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    r;

    /* Initialize rule variables
     */


    r       = NULL;

    {
        // Ontology.g:167:5: ( T_OP_EXIST r= T_SY_NAME T_S_SLS s_concept )
        // Ontology.g:167:9: T_OP_EXIST r= T_SY_NAME T_S_SLS s_concept
        {
             MATCHT(T_OP_EXIST, &FOLLOW_T_OP_EXIST_in_op_exist727); 
            if  (HASEXCEPTION())
            {
                goto ruleop_existEx;
            }

            r = (pANTLR3_COMMON_TOKEN) MATCHT(T_SY_NAME, &FOLLOW_T_SY_NAME_in_op_exist731); 
            if  (HASEXCEPTION())
            {
                goto ruleop_existEx;
            }

             MATCHT(T_S_SLS, &FOLLOW_T_S_SLS_in_op_exist733); 
            if  (HASEXCEPTION())
            {
                goto ruleop_existEx;
            }

            FOLLOWPUSH(FOLLOW_s_concept_in_op_exist735);
            s_concept(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleop_existEx;
            }

            {
                 ctx->m_spContext->op_exist(r); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleop_existEx; /* Prevent compiler warnings */
    ruleop_existEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end op_exist */

/** 
 * $ANTLR start op_maxcard
 * Ontology.g:172:1: op_maxcard : T_OP_L n= T_VAL_UINT T_S_SLS r= T_SY_NAME T_S_SLS s_concept ;
 */
static void
op_maxcard(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    n;
    pANTLR3_COMMON_TOKEN    r;

    /* Initialize rule variables
     */


    n       = NULL;
    r       = NULL;

    {
        // Ontology.g:173:5: ( T_OP_L n= T_VAL_UINT T_S_SLS r= T_SY_NAME T_S_SLS s_concept )
        // Ontology.g:173:9: T_OP_L n= T_VAL_UINT T_S_SLS r= T_SY_NAME T_S_SLS s_concept
        {
             MATCHT(T_OP_L, &FOLLOW_T_OP_L_in_op_maxcard765); 
            if  (HASEXCEPTION())
            {
                goto ruleop_maxcardEx;
            }

            n = (pANTLR3_COMMON_TOKEN) MATCHT(T_VAL_UINT, &FOLLOW_T_VAL_UINT_in_op_maxcard769); 
            if  (HASEXCEPTION())
            {
                goto ruleop_maxcardEx;
            }

             MATCHT(T_S_SLS, &FOLLOW_T_S_SLS_in_op_maxcard771); 
            if  (HASEXCEPTION())
            {
                goto ruleop_maxcardEx;
            }

            r = (pANTLR3_COMMON_TOKEN) MATCHT(T_SY_NAME, &FOLLOW_T_SY_NAME_in_op_maxcard775); 
            if  (HASEXCEPTION())
            {
                goto ruleop_maxcardEx;
            }

             MATCHT(T_S_SLS, &FOLLOW_T_S_SLS_in_op_maxcard777); 
            if  (HASEXCEPTION())
            {
                goto ruleop_maxcardEx;
            }

            FOLLOWPUSH(FOLLOW_s_concept_in_op_maxcard779);
            s_concept(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleop_maxcardEx;
            }

            {
                 ctx->m_spContext->op_maxcard(n, r); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleop_maxcardEx; /* Prevent compiler warnings */
    ruleop_maxcardEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end op_maxcard */

/** 
 * $ANTLR start op_mincard
 * Ontology.g:178:1: op_mincard : T_OP_G n= T_VAL_UINT T_S_SLS r= T_SY_NAME T_S_SLS s_concept ;
 */
static void
op_mincard(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    n;
    pANTLR3_COMMON_TOKEN    r;

    /* Initialize rule variables
     */


    n       = NULL;
    r       = NULL;

    {
        // Ontology.g:179:5: ( T_OP_G n= T_VAL_UINT T_S_SLS r= T_SY_NAME T_S_SLS s_concept )
        // Ontology.g:179:9: T_OP_G n= T_VAL_UINT T_S_SLS r= T_SY_NAME T_S_SLS s_concept
        {
             MATCHT(T_OP_G, &FOLLOW_T_OP_G_in_op_mincard809); 
            if  (HASEXCEPTION())
            {
                goto ruleop_mincardEx;
            }

            n = (pANTLR3_COMMON_TOKEN) MATCHT(T_VAL_UINT, &FOLLOW_T_VAL_UINT_in_op_mincard813); 
            if  (HASEXCEPTION())
            {
                goto ruleop_mincardEx;
            }

             MATCHT(T_S_SLS, &FOLLOW_T_S_SLS_in_op_mincard815); 
            if  (HASEXCEPTION())
            {
                goto ruleop_mincardEx;
            }

            r = (pANTLR3_COMMON_TOKEN) MATCHT(T_SY_NAME, &FOLLOW_T_SY_NAME_in_op_mincard819); 
            if  (HASEXCEPTION())
            {
                goto ruleop_mincardEx;
            }

             MATCHT(T_S_SLS, &FOLLOW_T_S_SLS_in_op_mincard821); 
            if  (HASEXCEPTION())
            {
                goto ruleop_mincardEx;
            }

            FOLLOWPUSH(FOLLOW_s_concept_in_op_mincard823);
            s_concept(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleop_mincardEx;
            }

            {
                 ctx->m_spContext->op_mincard(n, r); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleop_mincardEx; /* Prevent compiler warnings */
    ruleop_mincardEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end op_mincard */

/** 
 * $ANTLR start op_constraint
 * Ontology.g:184:1: op_constraint : a= T_SY_ATTRIBUTE o= ( T_OP_G | T_OP_GEQ | T_OP_L | T_OP_LEQ | T_OP_EQ | T_OP_NEQ ) ( lit_value | lit_constant ) ;
 */
static void
op_constraint(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    a;
    pANTLR3_COMMON_TOKEN    o;

    /* Initialize rule variables
     */


    a       = NULL;
    o       = NULL;

    {
        // Ontology.g:185:5: (a= T_SY_ATTRIBUTE o= ( T_OP_G | T_OP_GEQ | T_OP_L | T_OP_LEQ | T_OP_EQ | T_OP_NEQ ) ( lit_value | lit_constant ) )
        // Ontology.g:185:9: a= T_SY_ATTRIBUTE o= ( T_OP_G | T_OP_GEQ | T_OP_L | T_OP_LEQ | T_OP_EQ | T_OP_NEQ ) ( lit_value | lit_constant )
        {
            a = (pANTLR3_COMMON_TOKEN) MATCHT(T_SY_ATTRIBUTE, &FOLLOW_T_SY_ATTRIBUTE_in_op_constraint855); 
            if  (HASEXCEPTION())
            {
                goto ruleop_constraintEx;
            }

            o=(pANTLR3_COMMON_TOKEN)LT(1);
            if ( LA(1) == T_OP_L || LA(1) == T_OP_G || ((LA(1) >= T_OP_GEQ) && (LA(1) <= T_OP_NEQ)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_op_constraint859;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_op_constraint859);    goto ruleop_constraintEx;
            }


            // Ontology.g:185:79: ( lit_value | lit_constant )
            {
                int alt8=2;
                switch ( LA(1) ) 
                {
                case T_VAL_STRING:
                case T_VAL_UINT:
                case T_SY_VARIABLE:
                case T_VAL_INT:
                case T_VAL_FLOAT:
                	{
                		alt8=1;
                	}
                    break;
                case T_SY_NAME:
                	{
                		alt8=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 8;
                    EXCEPTION->state        = 0;


                    goto ruleop_constraintEx;
                }

                switch (alt8) 
                {
            	case 1:
            	    // Ontology.g:185:80: lit_value
            	    {
            	        FOLLOWPUSH(FOLLOW_lit_value_in_op_constraint874);
            	        lit_value(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleop_constraintEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Ontology.g:185:92: lit_constant
            	    {
            	        FOLLOWPUSH(FOLLOW_lit_constant_in_op_constraint878);
            	        lit_constant(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleop_constraintEx;
            	        }


            	    }
            	    break;

                }
            }
            {
                 ctx->m_spContext->op_constraint(a, o); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleop_constraintEx; /* Prevent compiler warnings */
    ruleop_constraintEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end op_constraint */

/** 
 * $ANTLR start op_not
 * Ontology.g:190:1: op_not : T_OP_NOT s_concept ;
 */
static void
op_not(pOntologyParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // Ontology.g:191:5: ( T_OP_NOT s_concept )
        // Ontology.g:191:9: T_OP_NOT s_concept
        {
             MATCHT(T_OP_NOT, &FOLLOW_T_OP_NOT_in_op_not909); 
            if  (HASEXCEPTION())
            {
                goto ruleop_notEx;
            }

            FOLLOWPUSH(FOLLOW_s_concept_in_op_not911);
            s_concept(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleop_notEx;
            }

            {
                 ctx->m_spContext->op_not(); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleop_notEx; /* Prevent compiler warnings */
    ruleop_notEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end op_not */

/** 
 * $ANTLR start lit_value
 * Ontology.g:195:1: lit_value : (v= T_SY_VARIABLE | v= T_VAL_UINT | v= T_VAL_INT | v= T_VAL_FLOAT | v= T_VAL_STRING );
 */
static void
lit_value(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    v;

    /* Initialize rule variables
     */


    v       = NULL;

    {
        {
            //  Ontology.g:196:5: (v= T_SY_VARIABLE | v= T_VAL_UINT | v= T_VAL_INT | v= T_VAL_FLOAT | v= T_VAL_STRING )
            
            ANTLR3_UINT32 alt9;

            alt9=5;

            switch ( LA(1) ) 
            {
            case T_SY_VARIABLE:
            	{
            		alt9=1;
            	}
                break;
            case T_VAL_UINT:
            	{
            		alt9=2;
            	}
                break;
            case T_VAL_INT:
            	{
            		alt9=3;
            	}
                break;
            case T_VAL_FLOAT:
            	{
            		alt9=4;
            	}
                break;
            case T_VAL_STRING:
            	{
            		alt9=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 9;
                EXCEPTION->state        = 0;


                goto rulelit_valueEx;
            }

            switch (alt9) 
            {
        	case 1:
        	    // Ontology.g:196:9: v= T_SY_VARIABLE
        	    {
        	        v = (pANTLR3_COMMON_TOKEN) MATCHT(T_SY_VARIABLE, &FOLLOW_T_SY_VARIABLE_in_lit_value942); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelit_valueEx;
        	        }

        	        {
        	             ctx->m_spContext->lit_value_variable(v); 
        	        }

        	    }
        	    break;
        	case 2:
        	    // Ontology.g:197:9: v= T_VAL_UINT
        	    {
        	        v = (pANTLR3_COMMON_TOKEN) MATCHT(T_VAL_UINT, &FOLLOW_T_VAL_UINT_in_lit_value956); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelit_valueEx;
        	        }

        	        {
        	             ctx->m_spContext->lit_value_uint(v); 
        	        }

        	    }
        	    break;
        	case 3:
        	    // Ontology.g:198:9: v= T_VAL_INT
        	    {
        	        v = (pANTLR3_COMMON_TOKEN) MATCHT(T_VAL_INT, &FOLLOW_T_VAL_INT_in_lit_value973); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelit_valueEx;
        	        }

        	        {
        	             ctx->m_spContext->lit_value_int(v); 
        	        }

        	    }
        	    break;
        	case 4:
        	    // Ontology.g:199:9: v= T_VAL_FLOAT
        	    {
        	        v = (pANTLR3_COMMON_TOKEN) MATCHT(T_VAL_FLOAT, &FOLLOW_T_VAL_FLOAT_in_lit_value991); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelit_valueEx;
        	        }

        	        {
        	             ctx->m_spContext->lit_value_float(v); 
        	        }

        	    }
        	    break;
        	case 5:
        	    // Ontology.g:200:9: v= T_VAL_STRING
        	    {
        	        v = (pANTLR3_COMMON_TOKEN) MATCHT(T_VAL_STRING, &FOLLOW_T_VAL_STRING_in_lit_value1007); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelit_valueEx;
        	        }

        	        {
        	             ctx->m_spContext->lit_value_string(v); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulelit_valueEx; /* Prevent compiler warnings */
    rulelit_valueEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end lit_value */

/** 
 * $ANTLR start lit_list
 * Ontology.g:203:1: lit_list : T_S_LB lit_listitem ( T_S_COM lit_listitem )* T_S_RB ;
 */
static void
lit_list(pOntologyParser ctx)
{   
    /* Initialize rule variables
     */



            { ctx->m_spContext->lit_list_begin(); }
        
    {
        // Ontology.g:208:5: ( T_S_LB lit_listitem ( T_S_COM lit_listitem )* T_S_RB )
        // Ontology.g:208:9: T_S_LB lit_listitem ( T_S_COM lit_listitem )* T_S_RB
        {
             MATCHT(T_S_LB, &FOLLOW_T_S_LB_in_lit_list1042); 
            if  (HASEXCEPTION())
            {
                goto rulelit_listEx;
            }

            FOLLOWPUSH(FOLLOW_lit_listitem_in_lit_list1044);
            lit_listitem(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelit_listEx;
            }


            // Ontology.g:208:29: ( T_S_COM lit_listitem )*

            for (;;)
            {
                int alt10=2;
                switch ( LA(1) ) 
                {
                case T_S_COM:
                	{
                		alt10=1;
                	}
                    break;

                }

                switch (alt10) 
                {
            	case 1:
            	    // Ontology.g:208:30: T_S_COM lit_listitem
            	    {
            	         MATCHT(T_S_COM, &FOLLOW_T_S_COM_in_lit_list1047); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelit_listEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_lit_listitem_in_lit_list1049);
            	        lit_listitem(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelit_listEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */

             MATCHT(T_S_RB, &FOLLOW_T_S_RB_in_lit_list1053); 
            if  (HASEXCEPTION())
            {
                goto rulelit_listEx;
            }

            {
                 ctx->m_spContext->lit_list_end(); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelit_listEx; /* Prevent compiler warnings */
    rulelit_listEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end lit_list */

/** 
 * $ANTLR start op_in
 * Ontology.g:212:1: op_in : a= T_SY_ATTRIBUTE T_KW_IN ( lit_list | lit_constant ) ;
 */
static void
op_in(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    a;

    /* Initialize rule variables
     */


    a       = NULL;

    {
        // Ontology.g:213:5: (a= T_SY_ATTRIBUTE T_KW_IN ( lit_list | lit_constant ) )
        // Ontology.g:213:9: a= T_SY_ATTRIBUTE T_KW_IN ( lit_list | lit_constant )
        {
            a = (pANTLR3_COMMON_TOKEN) MATCHT(T_SY_ATTRIBUTE, &FOLLOW_T_SY_ATTRIBUTE_in_op_in1084); 
            if  (HASEXCEPTION())
            {
                goto ruleop_inEx;
            }

             MATCHT(T_KW_IN, &FOLLOW_T_KW_IN_in_op_in1086); 
            if  (HASEXCEPTION())
            {
                goto ruleop_inEx;
            }


            // Ontology.g:213:34: ( lit_list | lit_constant )
            {
                int alt11=2;
                switch ( LA(1) ) 
                {
                case T_S_LB:
                	{
                		alt11=1;
                	}
                    break;
                case T_SY_NAME:
                	{
                		alt11=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 11;
                    EXCEPTION->state        = 0;


                    goto ruleop_inEx;
                }

                switch (alt11) 
                {
            	case 1:
            	    // Ontology.g:213:35: lit_list
            	    {
            	        FOLLOWPUSH(FOLLOW_lit_list_in_op_in1089);
            	        lit_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleop_inEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Ontology.g:213:46: lit_constant
            	    {
            	        FOLLOWPUSH(FOLLOW_lit_constant_in_op_in1093);
            	        lit_constant(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleop_inEx;
            	        }


            	    }
            	    break;

                }
            }
            {
                 ctx->m_spContext->op_in(a); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleop_inEx; /* Prevent compiler warnings */
    ruleop_inEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end op_in */

/** 
 * $ANTLR start lit_listitem
 * Ontology.g:217:1: lit_listitem : v= T_SY_NAME ;
 */
static void
lit_listitem(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    v;

    /* Initialize rule variables
     */


    v       = NULL;

    {
        // Ontology.g:218:5: (v= T_SY_NAME )
        // Ontology.g:218:9: v= T_SY_NAME
        {
            v = (pANTLR3_COMMON_TOKEN) MATCHT(T_SY_NAME, &FOLLOW_T_SY_NAME_in_lit_listitem1125); 
            if  (HASEXCEPTION())
            {
                goto rulelit_listitemEx;
            }

            {
                 ctx->m_spContext->lit_list_iten(v); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelit_listitemEx; /* Prevent compiler warnings */
    rulelit_listitemEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end lit_listitem */

/** 
 * $ANTLR start s_concept
 * Ontology.g:223:1: s_concept : ( op_top | op_bottom | op_cond | op_univ | op_exist | op_maxcard | op_mincard | op_constraint | op_in | op_atom | op_not | T_S_LP s_expr T_S_RP );
 */
static void
s_concept(pOntologyParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  Ontology.g:224:5: ( op_top | op_bottom | op_cond | op_univ | op_exist | op_maxcard | op_mincard | op_constraint | op_in | op_atom | op_not | T_S_LP s_expr T_S_RP )
            
            ANTLR3_UINT32 alt12;

            alt12=12;

            switch ( LA(1) ) 
            {
            case T_SY_TOP:
            	{
            		alt12=1;
            	}
                break;
            case T_SY_BOTTOM:
            	{
            		alt12=2;
            	}
                break;
            case T_SY_COND:
            	{
            		alt12=3;
            	}
                break;
            case T_OP_UNIV:
            	{
            		alt12=4;
            	}
                break;
            case T_OP_EXIST:
            	{
            		alt12=5;
            	}
                break;
            case T_OP_L:
            	{
            		alt12=6;
            	}
                break;
            case T_OP_G:
            	{
            		alt12=7;
            	}
                break;
            case T_SY_ATTRIBUTE:
            	{
            		switch ( LA(2) ) 
            		{
            		case T_OP_L:
            		case T_OP_G:
            		case T_OP_GEQ:
            		case T_OP_LEQ:
            		case T_OP_EQ:
            		case T_OP_NEQ:
            			{
            				alt12=8;
            			}
            		    break;
            		case T_KW_IN:
            			{
            				alt12=9;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 12;
            		    EXCEPTION->state        = 8;


            		    goto rules_conceptEx;
            		}

            	}
                break;
            case T_SY_NAME:
            	{
            		alt12=10;
            	}
                break;
            case T_OP_NOT:
            	{
            		alt12=11;
            	}
                break;
            case T_S_LP:
            	{
            		alt12=12;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 12;
                EXCEPTION->state        = 0;


                goto rules_conceptEx;
            }

            switch (alt12) 
            {
        	case 1:
        	    // Ontology.g:224:9: op_top
        	    {
        	        FOLLOWPUSH(FOLLOW_op_top_in_s_concept1155);
        	        op_top(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Ontology.g:224:18: op_bottom
        	    {
        	        FOLLOWPUSH(FOLLOW_op_bottom_in_s_concept1159);
        	        op_bottom(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Ontology.g:224:30: op_cond
        	    {
        	        FOLLOWPUSH(FOLLOW_op_cond_in_s_concept1163);
        	        op_cond(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // Ontology.g:224:40: op_univ
        	    {
        	        FOLLOWPUSH(FOLLOW_op_univ_in_s_concept1167);
        	        op_univ(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // Ontology.g:224:50: op_exist
        	    {
        	        FOLLOWPUSH(FOLLOW_op_exist_in_s_concept1171);
        	        op_exist(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // Ontology.g:224:61: op_maxcard
        	    {
        	        FOLLOWPUSH(FOLLOW_op_maxcard_in_s_concept1175);
        	        op_maxcard(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }


        	    }
        	    break;
        	case 7:
        	    // Ontology.g:224:74: op_mincard
        	    {
        	        FOLLOWPUSH(FOLLOW_op_mincard_in_s_concept1179);
        	        op_mincard(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }


        	    }
        	    break;
        	case 8:
        	    // Ontology.g:224:87: op_constraint
        	    {
        	        FOLLOWPUSH(FOLLOW_op_constraint_in_s_concept1183);
        	        op_constraint(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }


        	    }
        	    break;
        	case 9:
        	    // Ontology.g:224:103: op_in
        	    {
        	        FOLLOWPUSH(FOLLOW_op_in_in_s_concept1187);
        	        op_in(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }


        	    }
        	    break;
        	case 10:
        	    // Ontology.g:224:111: op_atom
        	    {
        	        FOLLOWPUSH(FOLLOW_op_atom_in_s_concept1191);
        	        op_atom(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }


        	    }
        	    break;
        	case 11:
        	    // Ontology.g:224:121: op_not
        	    {
        	        FOLLOWPUSH(FOLLOW_op_not_in_s_concept1195);
        	        op_not(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }


        	    }
        	    break;
        	case 12:
        	    // Ontology.g:225:9: T_S_LP s_expr T_S_RP
        	    {
        	         MATCHT(T_S_LP, &FOLLOW_T_S_LP_in_s_concept1205); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_s_expr_in_s_concept1207);
        	        s_expr(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }

        	         MATCHT(T_S_RP, &FOLLOW_T_S_RP_in_s_concept1209); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rules_conceptEx;
        	        }

        	        {
        	             ctx->m_spContext->s_concept(); 
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rules_conceptEx; /* Prevent compiler warnings */
    rules_conceptEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end s_concept */

/** 
 * $ANTLR start s_def
 * Ontology.g:230:1: s_def : T_KW_DEF v= T_SY_NAME ( lit_value | lit_list ) T_S_SEMI ;
 */
static void
s_def(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    v;

    /* Initialize rule variables
     */


    v       = NULL;

    {
        // Ontology.g:231:5: ( T_KW_DEF v= T_SY_NAME ( lit_value | lit_list ) T_S_SEMI )
        // Ontology.g:231:9: T_KW_DEF v= T_SY_NAME ( lit_value | lit_list ) T_S_SEMI
        {
             MATCHT(T_KW_DEF, &FOLLOW_T_KW_DEF_in_s_def1239); 
            if  (HASEXCEPTION())
            {
                goto rules_defEx;
            }

            v = (pANTLR3_COMMON_TOKEN) MATCHT(T_SY_NAME, &FOLLOW_T_SY_NAME_in_s_def1243); 
            if  (HASEXCEPTION())
            {
                goto rules_defEx;
            }


            // Ontology.g:231:30: ( lit_value | lit_list )
            {
                int alt13=2;
                switch ( LA(1) ) 
                {
                case T_VAL_STRING:
                case T_VAL_UINT:
                case T_SY_VARIABLE:
                case T_VAL_INT:
                case T_VAL_FLOAT:
                	{
                		alt13=1;
                	}
                    break;
                case T_S_LB:
                	{
                		alt13=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 13;
                    EXCEPTION->state        = 0;


                    goto rules_defEx;
                }

                switch (alt13) 
                {
            	case 1:
            	    // Ontology.g:231:31: lit_value
            	    {
            	        FOLLOWPUSH(FOLLOW_lit_value_in_s_def1246);
            	        lit_value(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rules_defEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Ontology.g:231:43: lit_list
            	    {
            	        FOLLOWPUSH(FOLLOW_lit_list_in_s_def1250);
            	        lit_list(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rules_defEx;
            	        }


            	    }
            	    break;

                }
            }
             MATCHT(T_S_SEMI, &FOLLOW_T_S_SEMI_in_s_def1253); 
            if  (HASEXCEPTION())
            {
                goto rules_defEx;
            }

            {
                 ctx->m_spContext->s_def(v); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rules_defEx; /* Prevent compiler warnings */
    rules_defEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end s_def */

/** 
 * $ANTLR start lit_constant
 * Ontology.g:236:1: lit_constant : v= T_SY_NAME ;
 */
static void
lit_constant(pOntologyParser ctx)
{   
    pANTLR3_COMMON_TOKEN    v;

    /* Initialize rule variables
     */


    v       = NULL;

    {
        // Ontology.g:237:5: (v= T_SY_NAME )
        // Ontology.g:237:9: v= T_SY_NAME
        {
            v = (pANTLR3_COMMON_TOKEN) MATCHT(T_SY_NAME, &FOLLOW_T_SY_NAME_in_lit_constant1285); 
            if  (HASEXCEPTION())
            {
                goto rulelit_constantEx;
            }

            {
                 ctx->m_spContext->lit_constant(v); 
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelit_constantEx; /* Prevent compiler warnings */
    rulelit_constantEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end lit_constant */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
